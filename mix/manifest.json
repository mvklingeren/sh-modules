{
  "id": "mix",
  "name": "Voxel World Demo",
  "version": "1.0.0",
  "active": true,
  "description": "voxel world with PBR materials, textures and animations",
  "entry": {
    "type": "javascript",
    "script": "main.js",
    "validation": {
      "required": true
    }
  },
  "resources": [
    {
      "id": "defaultVertexShader",
      "type": "vertexShader",
      "source": {
        "type": "inline",
        "data": "#version 300 es\nprecision highp float;\n\n// Required attributes\nin vec3 position;\nin vec3 normal;\n\n#ifdef USE_UV\nin vec2 uv;\n#endif\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nout vec3 vColor;\n\nvoid main() {\n    // Simple MVP transformation\n    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(position, 1.0);\n    \n    // Use normal for coloring to verify it's working\n    vColor = normalize(normal) * 0.5 + 0.5;\n}"
      }
    },
    {
      "id": "defaultFragmentShader",
      "type": "fragmentShader",
      "source": {
        "type": "inline",
        "data": "#version 300 es\nprecision highp float;\n\nout vec4 fragColor;\n\nvoid main() {\n    fragColor = vec4(1.0, 0.0, 1.0, 1.0);\n}"
      }
    },
    {
      "id": "skyVertexShader",
      "type": "vertexShader",
      "source": {
        "type": "inline",
        "data": "#version 300 es\nprecision highp float;\n\nin vec3 position;\nin vec3 normal;\nin vec2 uv;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform float uTime;\n\nout vec3 vNormal;\nout vec3 vWorldPos;\nout vec2 vUv;\n\nvoid main() {\n    vNormal = normalize(mat3(uModelMatrix) * normal);\n    vec4 worldPosition = uModelMatrix * vec4(position, 1.0);\n    vWorldPos = worldPosition.xyz;\n    vUv = uv;\n    gl_Position = uProjectionMatrix * uViewMatrix * worldPosition;\n}"
      }
    },
    {
      "id": "skyFragmentShader",
      "type": "fragmentShader",
      "source": {
        "type": "inline",
        "data": "#version 300 es\nprecision highp float;\n\nin vec3 vNormal;\nin vec3 vWorldPos;\nin vec2 vUv;\n\nuniform float uTime;\n\nout vec4 fragColor;\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v) {\n    const vec2 C = vec2(1.0/6.0, 1.0/3.0);\n    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    vec3 i  = floor(v + dot(v, C.yyy));\n    vec3 x0 = v - i + dot(i, C.xxx);\n\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy;\n    vec3 x3 = x0 - D.yyy;\n\n    i = mod289(i);\n    vec4 p = permute(permute(permute(\n        i.z + vec4(0.0, i1.z, i2.z, 1.0))\n        + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n        + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n    float n_ = 0.142857142857;\n    vec3 ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_);\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n    vec3 p0 = vec3(a0.xy, h.x);\n    vec3 p1 = vec3(a0.zw, h.y);\n    vec3 p2 = vec3(a1.xy, h.z);\n    vec3 p3 = vec3(a1.zw, h.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat cloudLayer(vec3 p, float scale, float speed, float density) {\n    vec3 pos = vec3(p.x * scale, p.y * scale + uTime * speed, p.z * scale);\n    float noise = snoise(pos);\n    noise += snoise(pos * 2.0) * 0.5;\n    noise += snoise(pos * 4.0) * 0.25;\n    return smoothstep(0.4, 0.6, noise) * density;\n}\n\nvoid main() {\n    vec3 skyTop = vec3(0.1, 0.3, 0.6);\n    vec3 skyHorizon = vec3(0.5, 0.7, 1.0);\n    vec3 sunsetColor = vec3(1.0, 0.4, 0.2);\n\n    float dayTime = sin(uTime * 0.1) * 0.5 + 0.5;\n    vec3 topColor = mix(skyTop, sunsetColor, pow(1.0 - dayTime, 4.0));\n    vec3 horizonColor = mix(skyHorizon, sunsetColor * 0.8, pow(1.0 - dayTime, 3.0));\n\n    float skyGradient = pow(max(0.0, vNormal.y), 0.4);\n    vec3 skyColor = mix(horizonColor, topColor, skyGradient);\n\n    vec3 sunDir = normalize(vec3(sin(uTime * 0.1), max(0.1, sin(uTime * 0.05)), cos(uTime * 0.1)));\n    float sunDot = max(0.0, dot(normalize(vNormal), sunDir));\n    vec3 sunColor = mix(vec3(1.0, 0.6, 0.3), vec3(1.0, 0.9, 0.7), dayTime);\n    float sunIntensity = pow(sunDot, 256.0) * 2.0;\n    float sunGlow = pow(sunDot, 8.0) * 0.5;\n\n    vec3 worldPos = vWorldPos * 0.001;\n    float clouds = 0.0;\n    clouds += cloudLayer(worldPos, 1.0, 0.2, 0.5);\n    clouds += cloudLayer(worldPos, 2.0, 0.3, 0.3);\n    clouds += cloudLayer(worldPos, 4.0, 0.5, 0.2);\n\n    vec3 cloudColor = mix(vec3(1.0), sunColor, 0.2);\n    cloudColor = mix(cloudColor, skyColor * 1.2, 0.5);\n    float cloudMask = smoothstep(-0.2, 0.6, vNormal.y);\n    \n    skyColor = mix(skyColor, cloudColor, clouds * cloudMask * (0.8 + sunGlow * 0.2));\n\n    skyColor += sunColor * sunIntensity;\n    skyColor += sunColor * sunGlow * 0.3;\n\n    float atmosphereGlow = pow(1.0 - abs(vNormal.y), 4.0);\n    skyColor += mix(vec3(0.3, 0.6, 1.0), sunColor * 0.5, 1.0 - dayTime) * atmosphereGlow;\n\n    skyColor = pow(skyColor, vec3(0.9));\n    \n    fragColor = vec4(skyColor, 1.0);\n}"
      }
    }
  ],
  "config": {
    "uniforms": [
      {
        "name": "uTime",
        "type": "float",
        "defaultValue": 0.0
      },
      {
        "name": "uModelMatrix",
        "type": "mat4",
        "defaultValue": [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
      },
      {
        "name": "uViewMatrix",
        "type": "mat4",
        "defaultValue": [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
      },
      {
        "name": "uProjectionMatrix",
        "type": "mat4",
        "defaultValue": [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
      },
      {
        "name": "uLightPosition",
        "type": "vec3",
        "defaultValue": [50, 100, 50]
      },
      {
        "name": "uLightColor",
        "type": "vec3",
        "defaultValue": [1.2, 1.2, 1.0]
      },
      {
        "name": "uObjectColor",
        "type": "vec3",
        "defaultValue": [0.8, 0.8, 0.8]
      },
      {
        "name": "uMaterialType",
        "type": "int",
        "defaultValue": 0
      },
      {
        "name": "uRoughness",
        "type": "float",
        "defaultValue": 0.3
      },
      {
        "name": "uMetalness",
        "type": "float",
        "defaultValue": 0.0
      },
      {
        "name": "uEmission",
        "type": "float",
        "defaultValue": 0.0
      },
      {
        "name": "uAlpha",
        "type": "float",
        "defaultValue": 1.0
      },
      {
        "name": "uDiffuseMap",
        "type": "sampler2D",
        "defaultValue": 0
      },
      {
        "name": "uHasDiffuseMap",
        "type": "bool",
        "defaultValue": false
      }
    ]
  }
}